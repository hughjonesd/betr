<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Writing experiments with betr</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>





</head>

<body>
<h1>Writing experiments with betr</h1>

<h2>Contents</h2>

<ul>
<li><a href="#Rationale">Rationale</a></li>
<li><a href="#Installing-betr">Installing betr</a></li>
<li><a href="#An-example-betr-experiment">An example betr experiment</a></li>
<li><a href="#Writing-experiments">Writing experiments</a></li>
<li><a href="#Debugging-experiments">Debugging experiments</a></li>
<li><a href="#Testing-experiments">Testing experiments</a></li>
<li><a href="#Running-your-experiment-in-the-lab">Running your experiment in the lab</a></li>
</ul>

<h2>Rationale</h2>

<p>betr is an R package to design, test and run social scientific experiments. It 
uses the web to serve experiments, but it is suitable either for web- or 
lab-based experiments. It is designed to make writing, testing, debugging and 
running experiments as easy as possible.</p>

<h2>Why use betr?</h2>

<p>Typically, social science experiments are run using computer software. The most
widely used software by economists is <a href="www.iew.uzh.ch/ztree/">zTree</a>. Others 
are written in Java, Python, or PHP. So, why use betr? </p>

<p>The most important advantageis:</p>

<ul>
<li>betr is written in R, so you don&#39;t need to learn a new programming language
to use it.</li>
</ul>

<p>That is true if you know R already. If you don&#39;t know R, but are an early-career
social scientist, then you probably need to learn at least one statistical 
software package. If you learn R, then you will also be able to use it to run
experiments in betr.</p>

<p>Some other advantages are:</p>

<ul>
<li>Experiments can be written in a full-featured programming languages.</li>
</ul>

<p>While zTree&#39;s language lacks constructs such as functions, with betr you can use
all the features of R. <em>No more copy-pasting the same code across different periods.</em>
R built-ins are also useful for writing experiments. Here&#39;s a standard way
to randomize over your subjects in zTree:</p>

<pre><code>subjects.do{
  randomizer = random();
}
subjects.do{
  rand_id = count ( randomizer &gt;= : randomizer );
}
</code></pre>

<p>The same thing in R is just:</p>

<pre><code class="splus">rand_id &lt;- sample(1:N)
</code></pre>

<ul>
<li>betr uses HTML to display experiments to subjects.</li>
</ul>

<p>HTML is a powerful and flexible display language, so your experiments can be as
beautiful or as simple as you like.</p>

<ul>
<li>Debugging and testing is easy.</li>
</ul>

<p>Testing experiments by hand can be a pain. Typically, you have to open one window for
each of your subjects, then type in responses manually. betr lessens that pain
by allowing automatic replay of sessions. So, you can test manually once, then
rerun the test automatically. </p>

<ul>
<li>You can run experiments on the web or in the lab.</li>
</ul>

<p>Obviously, since betr uses HTML, you can serve web-based experiments. In your
lab, you only need a web browser on client machines.</p>

<ul>
<li>Error recovery is easy and safe.</li>
</ul>

<p>Things can go wrong in the lab. In a betr session, all client and experimenter 
interactions are stored on disk, so even if your server computer crashes, you can 
replay back to where you left off and restart the experiment.</p>

<ul>
<li>No need for session management, databases, cookies, etc. </li>
</ul>

<p>Languages like PHP are designed to respond to a single request, perhaps store some
information in a database, print out a 
web page, then die. When they get a new request, they start again, look
for session information to remember where they were, get info from the 
database&hellip;. This does not really suit the paradigm of an experiment where you 
want users to go through steps simultaneously in a carefully defined order. 
The resulting session and database management can be a hassle. </p>

<p>betr takes a different approach: a single persistent server process handles all 
requests from start to finish.
There&#39;s no need to talk to a database: data is held in memory. At any time you 
can see exactly where your subjects are, using simple R commands.
And your experiment can be written in a single source file. </p>

<h2>Installing betr</h2>

<p>To install betr just run:</p>

<pre><code class="splus">install.packages(&quot;devtools&quot;) # if not already installed
library(devtools)
install_github(&quot;betr&quot;, &quot;hughjonesd&quot;) # for the latest version
</code></pre>

<h2>An example betr experiment</h2>

<p>Typically you will define your experiment in a source file. Then, during a 
session, you will run it from the command line. Here&#39;s a source file for a
simple guessing game experiment.</p>

<pre><code class="splus">library(betr)

initialize_data_frame &lt;- function() {
  mydf &lt;&lt;- experiment_data_frame(expt, guess=NA, correct=NA)
}
expt &lt;- experiment(N=1, clients_in_url=TRUE, on_ready=initialize_data_frame,
      seats_file=NULL)

s1 &lt;- function(id, period, params) {
  me_now &lt;- mydf$id==id &amp; mydf$period==period
  if (&#39;guess&#39; %in% names(params)) {
    mydf$guess[me_now] &lt;&lt;- as.numeric(params$guess)
    mydf$correct[me_now] &lt;&lt;- if (params$guess == sample(1:10,1)) 1 else 0
    return(NEXT)
  }
  last_guess &lt;- &#39;&#39;
  me_before &lt;- mydf$id==id &amp; mydf$period == period -1
  if (period &gt; 1) last_guess &lt;- paste0(&#39;You guessed &#39;, mydf$guess[me_before], 
        &#39;... you were &#39;, if(mydf$correct[me_before]&gt;0) &#39;right!&#39; else &#39;wrong!&#39;)
  return(c(header(), sprintf(&quot;&lt;p color=&#39;red&#39;&gt;%s&lt;/p&gt;&quot;, last_guess),
    &quot;&lt;p&gt;Pick a number&lt;/p&gt;&quot;,
    &quot;&lt;form action=&#39;&#39; method=&#39;post&#39;&gt;&lt;select name=&#39;guess&#39;&gt;&quot;,
    paste0(&quot;&lt;option value=&#39;&quot;, 1:10,&quot;&#39;&gt;&quot;, 1:10, &quot;&lt;/option&gt;&quot;, collapse=&quot;&quot;),
    &quot;&lt;/select&gt;&quot;,
    &quot;&lt;input type=&#39;submit&#39; value=&#39;Submit&#39;&gt;&lt;/form&gt;&quot;,
    footer()))
}

add_stage(expt, period(), s1, times=5)
</code></pre>

<p>Let&#39;s look at this bit by bit.</p>

<p>Our first task is to prepare a data frame for our experiment. We could just 
do this by calling</p>

<pre><code class="splus">mydf &lt;&lt;- data.frame(id=1, period=1:5, guess=NA, correct=NA)
</code></pre>

<p>However, we want to make sure that our experiment is <em>replay-safe</em>. If we 
replay our experiment, either during testing or to recover from a problem in a
session, our experiment will be rerun from the start. But if our data has 
already been written, then this might affect how things work. To make sure
that replay will work exactly the same, we create a function 
<code>initialize_data_frame</code> that creates a fresh empty dataset. This
function will be called whenever the experiment is made ready, including
when it is replayed. Then the replay will populate our data frame just as it was.</p>

<p><code>experiment_data_frame</code> is a convenience function. It sets up a
data frame with the right number of rows and columns for our experiment &ndash; one
per subject per period. </p>

<p>Next we set our experiment up. The call to <code>experiment</code> returns an object of 
class Experiment, which we have called <code>expt</code>. <code>N=1</code> gives the number of 
participants, and <code>on_ready=initialize_data_frame</code> tells betr to call our 
function whenever the experiment is made ready. Don&#39;t worry about the other 
options for now.</p>

<p>In betr, experiments are composed of
<em>stages</em>. The next piece of code defines a function <code>s1</code>, which will be one of 
our experiment&#39;s stages. Ignoring the details, the structure of <code>s1</code>
is like:</p>

<pre><code class="splus">s1 &lt;- function(id, period, params) {
  # ...
  return(NEXT)
  # or ...
  return(&quot;some HTML&quot;)
}
</code></pre>

<p>Here&#39;s how this works. When a subject makes an HTTP request to betr, the current
stage is called with the subject&#39;s <code>id</code> (a number from 1 to N), the
subject&#39;s current <code>period</code>, and any parameters from the request &ndash; e.g.
data from a form filled in by the subject. The stage can then do one of three 
things:</p>

<ol>
<li>Return some HTML to the subject.
The subject stays on the same stage. For example, if you return
an HTML form, the same stage will be called when the subject fills in the form
and hits <em>Submit</em>.</li>
<li>Return the special constant <code>NEXT</code>.
The subject is then advanced to the next stage, which is immediately
called without parameters.</li>
<li>Return the special constant <code>WAIT</code>.
The subject is shown a &ldquo;waiting page&rdquo;. After a defined
time interval, this will autorefresh and the stage will again be called.</li>
</ol>

<p>In <code>s1</code>, the stage looks at whether there is a parameter called <code>guess</code>. If there
is, the stage records the subject&#39;s guess in the data frame <code>mydf</code>. It also
decides whether the subject guessed right, and records this in <code>mydf$correct</code>. </p>

<ul>
<li><p>Notice one difference with zTree: whereas zTree records all data in tables called
<em>subjects</em>, <em>globals</em> etc., in betr you are free to record your data how you like.
A typical way is to create a data frame with 1 row per subject per period.</p></li>
<li><p>Notice also that <code>mydf</code> is assigned to using the operator <code>&lt;&lt;-</code> rather than
the more usual operator <code>&lt;-</code>. This makes sure that assignment happens in the 
global environment, rather than just in the function&#39;s local environment.</p></li>
</ul>

<p>Having recorded the data, <code>s1</code> returns <code>NEXT</code> and moves the subject on. If we
aren&#39;t finished, <code>s1</code> will then be called again without parameters. <code>s1</code> will
then print out the guessing form so the subject can choose another number.</p>

<p>Lastly, we add our stage <code>s1</code> to the experiment:</p>

<pre><code class="splus">add_stage(expt, period(), s1, times=5)
</code></pre>

<p>What about the other thing here, <code>period()</code>? In fact, <code>period()</code> creates another
kind of stage, called (guess what?) a Period. This stage is very simple: it 
adds 1 to the subject&#39;s period counter, then returns <code>NEXT</code>. </p>

<p>The <code>times=5</code> argument repeats the whole sequence of stages 5 times. So
our experiment&#39;s stages are now:</p>

<blockquote>
<p>period, s1, period, s1, period, s1, period, s1, period, s1</p>
</blockquote>

<p>OK, we&#39;ve created our experiment. Now, we need to run it. Run the code above, or
put it in a file called <code>my_experiment.R</code> and source it:</p>

<pre><code class="splus">source(&quot;my_experiment.R&quot;)
</code></pre>

<p>Before we run it, let&#39;s take a look at it. On the command line, type</p>

<pre><code class="splus">expt
</code></pre>

<pre><code>## Name: betr   Status: Stopped Clients: 0/1    Periods: 5  Stages: 10
</code></pre>

<p>This gives you basic information about the experiment. <em>Clients</em> tells you how
many clients have connected, out of the experiment&#39;s N. <em>Periods</em> and 
<em>Stages</em> are self-explanatory. There are 5 periods because our experiment
had 5 periods in its stages. There are 10 stages including the 5 periods and
the 5 <code>s1</code> objects. Lastly, the <em>Status</em> tells us whether the experiment is 
<em>Stopped</em>, <em>Waiting</em>, <em>Started</em> or <em>Paused</em>. Right now it is <em>Stopped</em>. Let&#39;s
change that. On the command line, run:</p>

<pre><code class="splus">ready(expt)
</code></pre>

<pre><code>## Loading required package: tools
## starting httpd help server ... done
</code></pre>

<pre><code>## 
## Server started on host 127.0.0.1 and port 35538 . App urls are:
## 
##  http://127.0.0.1:35538/custom/betr
</code></pre>

<p>Typically, you will call <code>ready</code> when you want to start connecting subjects to
the experiment. <code>ready</code> does several things:</p>

<ul>
<li>Starts the web server so that subject computers can connect to the experiment;</li>
<li>Creates a new experiment session, with a date and time, and creates a folder
on disk to hold data about it;</li>
<li>Calls any function passed to <code>on_ready</code>, e.g. initializing your data.</li>
</ul>

<p>Now, <code>expt</code> will report more information:</p>

<pre><code class="splus">expt
</code></pre>

<pre><code>## Session: betr-2014-05-22-145145  Status: Waiting Clients: 0/1    Periods: 5  Stages: 10
## Serving at http://127.0.0.1:35538/custom/betr
</code></pre>

<p>The status has changed, and we see the session name. We also have a URL. Clients
can connect to this to view the experiment. You can do this manually: open your 
web browser and go to the URL <a href="http://127.0.0.1:35538/custom/betr/client-1">http://127.0.0.1:35538/custom/betr/client-1</a>. Or,
for a convenient shortcut, enter:</p>

<pre><code class="splus">web_test(expt)
</code></pre>

<p>on the R command line. You should see a page saying &ldquo;Waiting to start&rdquo;. It will 
refresh regularly. (If you get an error message, check your computer&#39;s firewall 
settings. You may need to allow access to certain ports.)</p>

<p>Before we start, let&#39;s see a bit more information about our experiment. Type:</p>

<pre><code class="splus">info(expt)
</code></pre>

<pre><code>## Session: betr-2014-05-22-145145  Status: Waiting Clients: 1/1    Periods: 5  Stages: 10
## Serving at http://127.0.0.1:35538/custom/betr 
## Subjects:
##     client IP id seat period stage  status
## 1 client-1 NA  1   NA      0     0 Running
## Period progression:
## 0: . [1]
</code></pre>

<p>This shows the same info as before, plus a list of subjects &ndash; just one.</p>

<p>Now we&#39;ve got our 1 subject, we&#39;re ready to start. On the command line, type:</p>

<pre><code class="splus">start(expt)
</code></pre>

<p>Now, when your browser page refreshes, you will see the first period of the 
guessing game. Complete a couple of guesses (good luck!). Use <code>info(expt)</code>
to watch your subject progressing. You can also look directly at your 
experimental data frame:</p>

<pre><code class="splus">mydf
</code></pre>

<pre><code>##   id period guess correct
## 1  1      1     6       0
## 2  1      2     2       0
## 3  1      3    NA      NA
## 4  1      4    NA      NA
## 5  1      5    NA      NA
</code></pre>

<p>At the end, you will see an &ldquo;experiment finished&rdquo; page in your browser, and
<code>info(expt)</code> will show that your subject has finished the experiment.</p>

<p>To stop the experiment serving, run</p>

<pre><code class="splus">halt(expt)
</code></pre>

<p>Now the server will halt, so clients can no longer connect, and the status
of the experiment will be &ldquo;Stopped&rdquo;. </p>

<p>Our experiment is finished, but our data is still there, as you can see if you
type <code>mydf</code>. To save it to a CSV file, run:</p>

<pre><code class="splus">write.csv(mydf, file=&quot;my-first-data.csv&quot;)
</code></pre>

<p>Lastly, let&#39;s replay our experiment. Enter</p>

<pre><code class="splus">replay(expt, ask=TRUE)
</code></pre>

<p>The command prompt should show </p>

<pre><code>replay&gt;
</code></pre>

<p>Enter &#39;d&#39; to see details of the first request from a client computer. Then enter
&#39;n&#39; to replay this request. Carry on entering &#39;d&#39; and &#39;n&#39;; eventually you will 
see your &#39;start&#39; command. Enter &#39;n&#39; three more times. Now enter <code>mydf</code>. You
will see that your data frame is back as it was in the middle of the experiment.
You can enter arbitrary R expressions. For a list of other commands, enter 
&#39;h&#39; or &#39;?&#39;.</p>

<h2>Writing experiments</h2>

<h3>Experiment parameters</h3>

<p>So far our experiment is rather trivial: guessing a random number. Let&#39;s change
it to have multiple subjects, each matched in groups, and getting paid if they 
all choose the same random number &ndash; i.e., a coordination game. By doing this,
we&#39;ll learn about the different kinds of Stages. So
far you&#39;ve met two kinds: simple functions which return <code>NEXT</code>, <code>WAIT</code> or some
HTML; and Period objects created using <code>period</code>. </p>

<p>We&#39;ll set up our data frame much as before:</p>

<pre><code class="splus">library(betr)
N &lt;- 8
nreps &lt;- 4
groupsize &lt;- 2
reward &lt;- 5 # reward in $

if (N %% groupsize &gt; 0) stop(&quot;N must be an exact multiple of groupsize&quot;)
Ngroups &lt;- N/groupsize


initialize &lt;- function() {
  mydf &lt;&lt;- experiment_data_frame(N=N, periods=nreps, guess=NA,
        group=rep(rep(1:Ngroups, each=groupsize), nreps))
}

expt &lt;- experiment(N=N, clients_in_url=TRUE, on_ready=initialize,
      seats_file=NULL)
</code></pre>

<p>Note that:</p>

<ul>
<li><p>Parameters for the experiment are set at the top of the file so they can be
edited easily.</p></li>
<li><p>The column <code>mydf$group</code> records each subject&#39;s group. In this case, subject ids
1-2 are in group 1, subject ids 3-4 are in group 2, and so on. This is not
randomized, but by default, betr randomizes IDs across subjects, so we are fine. 
If you wanted to explicitly randomize you could just add the following line to 
<code>initialize</code>:</p></li>
</ul>

<pre><code class="splus">mydf$group &lt;&lt;- sample(mydf$group)
</code></pre>

<p>If you wanted to redraw groups each round, you could do something like:</p>

<pre><code class="splus">groups &lt;- rep(1:Ngroups, each=groupsize)
for (i in 1:nperiods(expt)) mydf$group[mydf$period==i] &lt;&lt;- sample(groups)
</code></pre>

<ul>
<li>Notice as before that when we assign to <code>mydf</code>, we use the global assignment 
operator <code>&lt;&lt;-</code>.</li>
</ul>

<h3>Text Stages</h3>

<p>Let&#39;s add some instructions to our experiment. To do this, we&#39;ll use a TextStage
object.</p>

<pre><code class="splus">ins &lt;- text_stage(page=c(
  header(), 
  &quot;You will be matched in groups of size&quot;, groupsize,
  &quot;. If you each guess the same number, you will get a reward of $&quot;, reward,
  &quot;. &lt;form action=&#39;&#39;&gt;&lt;input type=&#39;Submit&#39; value=&#39;OK&#39;&gt;&lt;/form&gt;&quot;,
  footer()
))
add_stage(expt, ins)
</code></pre>

<p><code>text_stage</code> creates very simple stages: they display some text to the user, then
return <code>NEXT</code>. At the bottom of our text, we add an HTML form with a single submit
button. When the subject clicks this, he or she will move on to the next stage.</p>

<p>The functions <code>header()</code> and <code>footer()</code> create some simple HTML to start and
finish the web page. They are there for convenience. </p>

<p>We don&#39;t always want the user to be able to move on. Sometimes we would rather 
make them wait until the experimenter moves them on. Doing this is simple:</p>

<pre><code class="splus">ins2 &lt;- text_stage(page=c(
  header(), 
  &quot;Please wait for the experiment to begin!&quot;,
  footer()
), wait=TRUE)
add_stage(expt, ins2)
</code></pre>

<p>Now the user can&#39;t move on because there is no submit button. In addition,
even if the browser were refreshed, the text will simply redisplay because
of the <code>wait=TRUE</code> option. To move all subjects on manually from the command
line:</p>

<pre><code class="splus">next_stage(expt, 1:N)
</code></pre>

<p>Here <code>1:N</code> gives the subject ids as shown by <code>info(expt)</code>. Moving subjects
on manually might risk losing data, but as this stage is just displaying some 
text, we&#39;re fine.</p>

<h3>Form Stages</h3>

<p>Next we need to let subjects pick a number. Last time we did this with a 
function which either displayed an HTML form, or stored the subject&#39;s guess.
We can do this even more simply using a new kind of Stage: a FormStage object,
created by the <code>form_stage</code> function.</p>

<pre><code class="splus">myform &lt;- c(
  header(), &quot;&lt;p style=&#39;color:red;&#39;&gt;&lt;% errors %&gt;&lt;/p&gt;&quot;,
  &quot;&lt;p&gt;Pick a number:&lt;/p&gt;&quot;,
  &quot;&lt;form action=&#39;&#39; method=&#39;POST&#39;&gt;&lt;select name=&#39;guess&#39;&gt;&quot;,
  paste0(&#39;&lt;option&gt;&#39;, 1:10, &#39;&lt;/option&gt;&#39;), 
  &quot;&lt;/select&gt;&quot;,
  &quot;&lt;input type=&#39;submit&#39; value=&#39;Submit&#39;&gt;&lt;/form&gt;&quot;, 
  footer()
)
guess_s &lt;- form_stage(page=myform, fields=list(
      guess=all_of(is_whole_number(), is_between(1, 10))
      ), data_frame=&quot;mydf&quot;)
</code></pre>

<p>A form stage prints out an HTML form for the subject. When the form is submitted,
it is checked for errors. If there are no errors, the corresponding fields
in the database are updated. You specify which fields to update by the list
<code>fields</code>. The <em>names</em> of this list are names of form fields, which should also
be columns in your data frame. Each <em>value</em> in the list should be a function to check
the user-submitted data. You can write your own functions, but here we have
auto-generated one with <code>is_whole_number</code>, <code>is_between</code> and <code>all_of</code>. (These are
functions which return functions!) So, here we require the <code>guess</code> parameter to be
<em>both</em> a whole number, <em>and</em> between 1 and 10. </p>

<p>If there are errors in your fields, the form will be redisplayed. For convenience,
the string &ldquo;&lt;% errors %&gt;&rdquo; will be replaced by a list of errors. </p>

<p>Assuming that there are no errors, the data frame named in <code>data_frame</code> is
updated. Note that:</p>

<ul>
<li><code>data_frame</code> should be the name of the data frame, not the data frame itself &ndash; i.e.
<code>&quot;mydf&quot;</code> not <code>mydf</code>. </li>
<li>The data frame must exist in the global environment</li>
<li>The data frame is expected to be in the standard form returned by 
<code>experiment_data_frame</code>, that is:</li>
</ul>

<table><thead>
<tr>
<th>id</th>
<th>period</th>
<th>&hellip;</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>1</td>
<td>&hellip;</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>&hellip;</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>&hellip;</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>&hellip;</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
</tbody></table>

<ul>
<li>Form parameters are character vectors and will be stored in the database as
such (even if you&#39;ve checked them with e.g. <code>is_whole_number()</code>). </li>
</ul>

<h3>Checkpoints</h3>

<p>If we have multiple users in groups, we can&#39;t let them all run through the 
experiment at their own speed. They have to wait for each other. For this we need 
another kind of Stage called a CheckPoint.</p>

<pre><code class="splus">initialize() # creates mydf so we can use mydf$group
grp &lt;- mydf$group[mydf$period==1]
grp &lt;- grp[order(mydf$id[mydf$period==1])]
check_s &lt;-checkpoint(wait_for=grp)
</code></pre>

<p>CheckPoints simply hold subjects at a waiting page until some subjects have also
arrived at the checkpoint. You can specify which subjects to wait for by the 
<code>wait_for</code> argument to <code>checkpoint</code>. This can be <code>&quot;all&quot;</code> to wait for all subjects, or 
<code>&quot;ever&quot;</code> to wait forever. (This is useful if you want to let the experimenter 
move on subjects manually using <code>next_stage</code>.) Or, as in our example, it can be 
a vector of group names, sorted by id. When this happens, each subject will wait 
until everyone in his or her group has arrived. For example, if </p>

<pre><code class="splus">wait_for=c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
</code></pre>

<p>then subject IDs 1 and 3 will wait for each other, subject IDs 2 and 4 will wait
for each other, and subject ID 5 will not wait for anyone.</p>

<h3>Programs</h3>

<p>After each group has arrived at the checkpoint, we know that they have filled in
their guess. Now we can calculate if they&#39;ve coordinated correctly. We&#39;ll use
a Program stage for this. A Program simply runs some code at a particular point
in the experiment. It doesn&#39;t display anything to the subjects &ndash; they just move
on to the next stage.</p>

<pre><code class="splus">calculate_profit &lt;- function(id, period) {
  mydf$guess &lt;&lt;- as.numeric(mydf$guess)
  me_now &lt;- mydf$id == id &amp; mydf$period == period

  mygroup &lt;- mydf$group[me_now]
  myguesses &lt;- mydf$guess[mydf$group == mygroup &amp; mydf$period == period]
  profit &lt;- if (min(myguesses) == max(myguesses)) reward else 0
  mydf$profit[me_now] &lt;&lt;- profit

}
calc_s &lt;- program(run=&quot;all&quot;, fn=calculate_profit)
</code></pre>

<p>Here <code>calculate_profit</code> does just what it says. Note that the first line turns
<code>mydf$guess</code> into a numeric variable. Also, note how the first and last lines
use <code>&lt;&lt;-</code> to assign into <code>mydf</code> in the <em>global</em> environment.</p>

<p>The <code>run=&quot;all&quot;</code> argument runs the program once for every subject. In effect,
profit is calculated several times for every group, but the calculation doesn&#39;t 
change so it doesn&#39;t. Other values include <code>&quot;first&quot;</code> and <code>&quot;last&quot;</code>. These run
the program only when the first subject arrives, and only when the last subject
arrives, respectively.</p>

<h3>Putting it together</h3>

<p>Lastly, we&#39;ll add our stages to the experiment - not forgetting a period counter
using <code>period()</code>.</p>

<pre><code class="splus">add_stage(expt, period(), guess_s, check_s, calc_s, times=nreps)
</code></pre>

<p>The basic pattern here is: form stage, checkpoint, program. You can use this 
simple pattern in many experiments.</p>

<h3>Adding timeouts</h3>

<p>Often in lab experiments you want to give subjects only a fixed time to
answer a question, view instructions etc. In betr, you can do this by adding
timeouts to stages. The syntax is like:</p>

<pre><code class="splus">timed(stage, timeout=60)
</code></pre>

<p>where <code>stage</code> is the original stage, and <code>timeout</code> gives the number of seconds
before the stage times out. <code>timed</code> creates a new stage object of class Timed. 
So, for example, if we wanted to give subjects 30 seconds to guess a number , we
could write:</p>

<pre><code class="splus">add_stage(expt, period(), timed(guess_s, 30), check_s, calc_s, times=nreps)
</code></pre>

<p>Timeouts work by adding a <code>Refresh:</code> header to the http request. Client browsers
will automatically refresh after the timeout is called. If the timeout expires,
then the Timed stage returns <code>NEXT</code>. You may want to do something extra in this
case, like set some default values, or record that the subject timed out. You
can do this by adding an <code>on_timeout</code> argument to <code>timed</code>.</p>

<pre><code class="splus">timed(stage, timeout=60, on_timeout=function(id, period) {
  mydf[mydf$id==id &amp; mydf$period==period, &quot;timed_out_on_me&quot;] &lt;&lt;- TRUE
})
</code></pre>

<h3>Dynamic pages and images</h3>

<p>So far we have only shown the user static pages of HTML. That is rather limited.
We also want to customize the HTML to print out e.g. the past history of play.
We might also want to use R&#39;s powerful graphics facilities. </p>

<p>Actually, you have already seen one way to print HTML dynamically, which is 
just to use a <code>stage</code> function. For example, here&#39;s how to print out the 
subject&#39;s name, assuming they have already submitted it:</p>

<pre><code class="splus">stg &lt;- function(id, period, params) {
  c(header(), &quot;Your name is:&quot;, mydf$name[mydf$id==id &amp; mydf$period==period],
        footer())
}
</code></pre>

<p>You can do something very similar within a <code>text_stage</code> or <code>form_stage</code>. Instead
of passing a character vector of HTML to the <code>page</code> argument, pass a function:</p>

<pre><code class="splus">ts &lt;- text_stage(page=function(id, period, params, errors) {
  c(header(), &quot;Your name is:&quot;, mydf$name[mydf$id==id &amp; mydf$period==period],
        footer())  
})
</code></pre>

<p>The <code>params</code> and <code>errors</code> parameters will never be used in a text stage, since 
the stage prints only once after the last stage called <code>NEXT</code>. However, your 
function should always have them as arguments. </p>

<p>In a form stage you can do the same thing. The <code>params</code> argument will be a
list of the user-submitted parameters. It will be empty when the form is displayed
for the first time, but will have elements if the form redisplays because of user
errors. <code>error</code> is a named vector of error messages from form submission.
For example, the following prints out a simple HTML form, keeping user&#39;s previous
inputs and displaying any error messages:</p>

<pre><code class="splus">myfun &lt;- function(id, period, params, errors) {
  name &lt;- if (&#39;name&#39; %in% names(params)) params$name else &#39;&#39;
  age &lt;-  if (&#39;age&#39; %in% names(params)) params$age else &#39;&#39;
  html &lt;- header()
  if (length(errors) &gt; 0) html &lt;- c(html, 
        &quot;&lt;div style=&#39;color:red; border: 1px solid red;&#39;&gt;&quot;,
        paste(errors, collapse=&quot;&lt;br /&gt;&quot;), &quot;&lt;/div&gt;&quot;)
  html &lt;- c(html, 
        &quot;&lt;form action=&#39;&#39; method=&#39;POST&#39;&gt;&quot;,
        sprintf(&quot;&lt;h1&gt;Period %s: enter your details&lt;/h1&gt;&quot;, period),
        sprintf(&quot;&lt;p&gt;Name: &lt;input type=&#39;text&#39; name=&#39;name&#39; value=&#39;%s&#39;&gt;&lt;/p&gt;&quot;, name),
        sprintf(&quot;&lt;p&gt;Age: &lt;input type=&#39;number&#39; name=&#39;age&#39; value=&#39;%s&#39;&gt;&lt;/p&gt;&quot;, age),
        &quot;&lt;/form&gt;&quot;, 
        footer())
  return(html)
}

fs &lt;- form_stage(page=myfun, fields=list(
        name=has_value(), 
        age=is_between(18,110)
      ), data_frame=&quot;mydf&quot;)

# test how this works:
myfun(id=1, period=3, params=list(name=&#39;John&#39;, age=&#39;19&#39;), errors=&#39;&#39;)
</code></pre>

<pre><code>##  [1] &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Experiment&lt;/title&gt;&lt;/head&gt;\n        &lt;body style=&#39;background-color: #CCCCCC; padding: 2% 4%;&#39;&gt;\n        &lt;div style=&#39;background-color: white; padding: 3% 3%; \n        border: 1px solid #888888; border-radius: 10px;&#39;&gt;&quot;
##  [2] &quot;&lt;div style=&#39;color:red; border: 1px solid red;&#39;&gt;&quot;                                                                                                                                                                                          
##  [3] &quot;&quot;                                                                                                                                                                                                                                         
##  [4] &quot;&lt;/div&gt;&quot;                                                                                                                                                                                                                                   
##  [5] &quot;&lt;form action=&#39;&#39; method=&#39;POST&#39;&gt;&quot;                                                                                                                                                                                                           
##  [6] &quot;&lt;h1&gt;Period 3: enter your details&lt;/h1&gt;&quot;                                                                                                                                                                                                    
##  [7] &quot;&lt;p&gt;Name: &lt;input type=&#39;text&#39; name=&#39;name&#39; value=&#39;John&#39;&gt;&lt;/p&gt;&quot;                                                                                                                                                                                
##  [8] &quot;&lt;p&gt;Age: &lt;input type=&#39;number&#39; name=&#39;age&#39; value=&#39;19&#39;&gt;&lt;/p&gt;&quot;                                                                                                                                                                                  
##  [9] &quot;&lt;/form&gt;&quot;                                                                                                                                                                                                                                  
## [10] &quot;&lt;/div&gt;&lt;div align=&#39;center&#39; style=&#39;padding: 10px 10px;&#39;&gt;betr&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>

<h3>Brew and knitr</h3>

<p>Using functions which mix R and HTML can start to look rather messy, as the code
above shows. A nicer solution is to use a templating package. This means
you create your HTML pages in a separate file, and mix in a little R, keeping
most of your experiment logic separate. R has two powerful templating packages,
<a href="http://cran.r-project.org/package=brew">brew</a> and <a href="http://yihui.name/knitr/">knitr</a>.</p>

<p>Brew is almost self-explanatory. Here&#39;s a brew file that would recreate the HTML
form above:</p>

<pre><code class="html">&lt;%
name &lt;- if (&#39;name&#39; %in% names(params)) params$name else &#39;&#39;
age &lt;-  if (&#39;age&#39; %in% names(params)) params$age else &#39;&#39;
%&gt;
&lt;html&gt;
&lt;body&gt;
&lt;% if (length(errors) &gt; 0) { %&gt;
  &lt;div style=&#39;color:red; border: 1px solid red;&#39;&gt;
  &lt;%= paste(errors, collapse=&quot;&lt;br /&gt;&quot;) %&gt;
  &lt;/div&gt;
&lt;% } %&gt;
&lt;form action=&#39;&#39; method=&#39;POST&#39;&gt;
&lt;h1&gt;Period &lt;%= period %&gt;: enter your details&lt;/h1&gt;
&lt;p&gt;Name: &lt;input type=&#39;text&#39; name=&#39;name&#39; value=&#39;&lt;%= name %&gt;&#39;&gt;&lt;/p&gt;
&lt;p&gt;Age: &lt;input type=&#39;number&#39; name=&#39;age&#39; value=&#39;&lt;%= age %&gt;&#39;&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Code between <code>&lt;% %&gt;</code> tags is evaluated. Code between <code>&lt;%= %&gt;</code> tags is 
evaluated and printed out. Notice that the values of <code>id</code>, <code>period</code>, <code>params</code> and 
<code>errors</code> are available within the brew file.</p>

<p>To use this within your form stage, use <code>b_brew</code>:</p>

<pre><code class="splus">fs &lt;- form_stage(page=b_brew(&quot;path_to_brew.html&quot;), fields=list(
        name=has_value(), 
        age=is_between(18,110)
      ), data_frame=&quot;mydf&quot;)
</code></pre>

<p>knitr is a similar templating framework. Its syntax is slightly more complex, 
but it has a powerful advantage: it can dynamically generate graphics.</p>

<p>Here&#39;s a knitr HTML file that might be part of a public goods game.</p>

<pre><code>&lt;!--begin.rcode results=&#39;hide&#39;

myid &lt;- which(mydf$id==id &amp; mydf$period==period)
mygroup &lt;- mydf$group[myid]
contribs &lt;- mydf[mydf$group==mygroup, c(&quot;contrib&quot;, &quot;period&quot;, &quot;id&quot;)]
contribs &lt;- contribs[order(contribs$period, contribs$id),]
last_contribs &lt;- tail(contribs$contrib, groupsize)

end.rcode--&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;Period &lt;!--rinline I(period) --&gt;&lt;/h1&gt;

&lt;p&gt;Group contributions were:&lt;/p&gt;
&lt;!--begin.rcode 
cat(paste(last_contribs, collapse=&quot;&lt;br /&gt;&quot;))
end.rcode--&gt;. 

&lt;p&gt;History of contributions:&lt;/p&gt;

&lt;!--begin.rcode
plot(contribs$period, contribs$contrib, col=contribs$id, type=&quot;n&quot;,
    xlab=&quot;Period&quot;, ylab=&quot;Contribution&quot;, ylim=c(0,50))
for (mem_id in unique(contribs$id)) {
  ct &lt;- contribs[contribs$id==mem_id,]
  lines(ct$period, ct$contrib, col=mem_id, type=&quot;b&quot;)
}
end.rcode--&gt;

&lt;/body&gt;
&lt;/html&gt;

</code></pre>

<p>This prints out an HTML page with an embedded image something like this:</p>

<p><img src="figure/unnamed-chunk-35.pdf" alt="plot of chunk unnamed-chunk-35"/> </p>

<p>The equivalent of <code>&lt;% ... %&gt;</code> in knitr is <code>&lt;!--begin.rcode ... end.rcode--&gt;</code>.
You can also use <code>&lt;!--rinline ... --&gt;</code> for small chunks of code. knitr prints
images directly in the HTML page, so you don&#39;t need to worry about where to put
separate image files. Note that unlike brew, you have to actually print out
the results you want to see using e.g. <code>cat</code>. However, <code>rinline</code> chunks are
printed out verbatim. A helpful trick which we used above 
is to wrap items in <code>&lt;!--rinline ... --&gt;</code> blocks in the function <code>I()</code>. 
This prevents knitr surrounding them with special formatting.</p>

<p>betr customizes knitr&#39;s options to produce suitable output. See <code>?b_knit</code> and 
the <a href="http://yihui.name/knitr/">knitr documentation</a> for more details. </p>

<h2>Debugging experiments</h2>

<p>Code can go wrong. Sooner or later, your experiment will throw an error or, 
worse still, will do something unexpected without printing an error message.
Luckily, R has powerful facilities for debugging.</p>

<p>Here&#39;s part of a dictator game experiment:</p>

<pre><code class="splus">init_df &lt;- function() {
  mydf &lt;- experiment_data_frame(expt)
  mydf$give &lt;- NA
}
expt &lt;- experiment(N=2, autostart=TRUE, clients_in_url=TRUE, on_ready=init_df)
dict_form &lt;- c(header(), 
      &quot;Choose how much to give: &lt;form method=&#39;POST&#39; action=&#39;&#39;&gt;&quot;,
      &quot;&lt;input type=&#39;text&#39; name=&#39;give&#39; maxlength=&#39;2&#39;&gt;&quot;, 
      &quot;&lt;input type=&#39;submit&#39; value=&#39;Submit&#39;&gt;&lt;/form&gt;&quot;,footer())
dict_stage &lt;- form_stage(dict_form, fields=list(give=is_between(0, 10)), 
      data_frame=&quot;mydf&quot;)
add_stage(expt, period(), dict_stage)
</code></pre>

<p>If you run this experiment, you&#39;ll get an error:</p>

<pre><code class="splus">ready(expt)
</code></pre>

<pre><code>## starting httpd help server ... done
</code></pre>

<pre><code>## 
## Server started on host 127.0.0.1 and port 35538 . App urls are:
## 
##  http://127.0.0.1:35538/custom/betr
</code></pre>

<pre><code class="splus">## web_test(expt) # and submit a number in your browser
</code></pre>

<pre><code>## [1] &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Experiment&lt;/title&gt;&lt;meta http-equiv=&#39;refresh&#39; content=&#39;5&#39;&gt;&lt;/head&gt;\n        &lt;body style=&#39;background-color: #CCCCCC; padding: 2% 4%;&#39;&gt;\n        &lt;div style=&#39;background-color: white; padding: 3% 3%; \n        border: 1px solid #888888; border-radius: 10px;&#39;&gt;Waiting to start&lt;/div&gt;&lt;div align=&#39;center&#39; style=&#39;padding: 10px 10px;&#39;&gt;betr&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>

<p>This tells us what is wrong: <code>mydf</code> has not been created in the global 
environment. At this point, you should look at the code in <code>init_df</code>, which
is supposed to create <code>mydf</code> when the experiment is made ready. If you are lucky,
you&#39;ll notice that it is using <code>&lt;-</code> instead of <code>&lt;&lt;-</code>: <code>mydf</code> is being created
only within the function, not in the global environment. Let&#39;s suppose you are
unlucky and don&#39;t know why <code>mydf</code> isn&#39;t being created. We can check what&#39;s
happening by using the built-in debugger.</p>

<pre><code class="splus">debug(init_df)
init_df()
</code></pre>

<p>The call to <code>debug</code> means that when <code>init_df()</code> is called, you step into it and
evaluate it one line at a time. In the debugger, enter &#39;n&#39; to move on a line. 
You can also
enter any other R expression and it will be evaluated. So, enter &#39;n&#39; until you
have run <code>experiment_data_frame</code>, then enter <code>mydf</code>. You&#39;ll see that your data
frame exists and looks OK. Then when you exit the debugger, enter <code>mydf</code> again
&ndash; you will see that <code>mydf</code> no longer exists. This will hopefully give you a 
clue to what is happening: <code>mydf</code> is being created OK, but assigned in the wrong
place. When you&#39;ve finished debugging, call <code>undebug(init_df)</code> to return
to normal behaviour.</p>

<p>Debugging works while you are running an experiment: the browser will hang,
waiting for a response, while you step through the debugger.</p>

<p>Often you will want to debug code that is happening inside an experiment stage.
To do that, call <code>trace_stage(expt, n, browser)</code> on your experiment. Here <code>n</code> is
the number of the stage in the experiment. This
will put you into debug mode whenever this stage is called. For example, in the
experiment above <code>trace_stage(expt, 2, browser)</code> will debug <code>dict_stage</code>. Call
<code>untrace_stage(expt, 2)</code> to go back to normal mode.</p>

<p>See <code>?debug</code>, <code>?trace</code>, <code>?browser</code> and <code>?recover</code> for more details, as well as
the method <code>trace</code> in <code>?setRefClass</code>.</p>

<p><code>replay</code> is often useful for debugging: see the next section.</p>

<h2>Testing experiments</h2>

<p>We&#39;ve already seen how to test your experiments manually, using 
<code>web_test(expt)</code>. However, if your experiment has 16 participants, this quickly
becomes laborious. Luckily, we can automate the process using <code>replay</code>.</p>

<p>In the experiment above, we might want to test several things, such as:</p>

<ol>
<li>Does the experiment start and run without throwing an R error?</li>
<li>If subjects get the same number, do they get a profit of $5?</li>
<li>If subjects get a different number, do they get a profit of $0?</li>
<li>If a subject enters a number less than 0 or greater than 10 or not a whole
number, does the script print an error and ask for input again?</li>
</ol>

<h4>Testing with <code>replay</code></h4>

<p>To use <code>replay</code> you will first need to test your session manually, using 
<code>web_test</code>. This may be slow, but you need only do it once. Just by doing this,
you already test question 1 above: you can&#39;t run the experiment if it won&#39;t run!
When you have finished, check that things are how you expected. Then, note down 
the session name (printed by <code>info(expt)</code>). You should find a folder with the 
corresponding session name on your hard drive, in the folder where R started. 
Note the folder name.</p>

<p>Now, make some changes to your code. After you&#39;ve saved the experiment file and
(perhaps) restarted R, source the file again and enter:</p>

<pre><code class="splus">ready(expt)
replay(expt, folder=&quot;[the folder name you noted earlier]&quot;)
</code></pre>

<p>This will replay your previous session <em>instantly</em>. Afterwards, you can check again
that things are still as you expect. You don&#39;t have to include the folder name:
if you don&#39;t, betr will try to find the most recent folder that looks like a
session record.</p>

<p>You can automate the process still further by a testing package such as <code>testthat</code>. Here&#39;s a simple example, checking that a data frame has the right number of rows
and that the <code>give</code> field is always defined.</p>

<pre><code class="splus">test_that(&quot;Data frame created OK&quot;, {
  source(&quot;my-experiment-file.R&quot;) # defines an experiment myexp
  replay(myexp, folder=&quot;myexp-2014-05-15-120000&quot;) # test from 12 pm on 15 May 
  expect_that(nrow(mydf), equals(32)) 
  expect_false(is.na(mydf$give)) # 
})
</code></pre>

<p>Automated testing makes it easier to run tests &ndash; which should make your
experiments more reliable.</p>

<h2>Running your experiment in the lab</h2>

<p>When you&#39;ve tested on your computer, you&#39;ll want to try it in the laboratory.
This section describes how to prepare the laboratory to run betr experiments.</p>

<h3>Installing betr on a server computer</h3>

<p>The install process for betr is as described above. You could either use a 
computer in the lab, or a remote server. The lab client
computers must be able to connect to this server. </p>

<p>So far, we&#39;ve only been serving betr to our own computer. This has hidden a 
small problem: betr relies on the R package 
<a href="http://cran.r-project.org/package=Rook">Rook</a>, and Rook&#39;s web server can
<em>only</em> serve to our own computer. Obviously that is not very useful now it is 
time to go live!</p>

<p>The simplest solution to this is to use a proxy web server in front of betr on the
same computer, which redirects requests to betr. betr then serves the requests 
(now coming from its own computer) and the proxy returns them. </p>

<p>One way to do this is using the standard <a href="http://httpd.apache.org">Apache</a> web 
server. The steps to do this are:</p>

<ol>
<li>Download and install Apache</li>
</ol>

<p>On Debian or Ubuntu Linux systems, run <code>sudo apt-get install apache2</code>.</p>

<ol>
<li>Enable the Apache module <code>mod_proxy</code>. Again, on Debian/Ubuntu:</li>
</ol>

<pre><code>sudo a2enmod mod_proxy
sudo a2enmod proxy_http
sudo service apache2 restart
</code></pre>

<ol>
<li>Edit your Apache config file to include the line:</li>
</ol>

<pre><code>ProxyPass /betr/ http://127.0.0.1:35538/custom/
</code></pre>

<p>Here, <code>35538</code> is the port betr will serve on internally. (This is the default
port: you can change it using the <code>port</code> argument to <code>experiment()</code>.)
You can check this works by running something like this in R:</p>

<pre><code class="splus">experiment(N=1, name=&quot;foo&quot;, autostart=TRUE)
add_stage(experiment, text_stage(c(header(), &quot;Success!&quot;, footer())))
ready(expt)
</code></pre>

<p>Now, if you request the web page <code>http://your.server.name/betr/foo</code>, Apache will 
forward this to <code>http://127.0.0.1:35538/custom/foo</code>. </p>

<h3>Kiosk mode</h3>

<p>Your lab client computers don&#39;t need any special software &ndash; just a web browser.
However, you don&#39;t want your subjects to start reading Facebook if they get 
bored. To lock down the web browser, you may wish to install a &ldquo;Kiosk mode&rdquo;
extension. This should:</p>

<ul>
<li>hide the URL bar and other toolbars</li>
<li>prevent the user using the back or refresh buttons</li>
</ul>

<p>Ideally, you also want to prevent users using <code>Alt+F4</code> or <code>Ctrl+Alt+Delete</code> to
switch applications&hellip; but your lab does that already, right? ;-)</p>

<p>Google Chrome comes with a built-in kiosk mode, which you can enable by running
<code>chrome --kiosk &quot;http://starting.url&quot;</code>. For Firefox, there is the 
<a href="https://addons.mozilla.org/en-us/firefox/addon/r-kiosk/">Rkiosk extension</a>.
Internet Explorer appears to have a built-in kiosk mode enabled by 
<code>iexplore.exe -k</code>.</p>

<p>Another thing you may wish to do is ensure that only certain computers can
connect to your experiment. You can do this with the <code>auth</code> argument to 
<code>experiment</code>. Here&#39;s how to allow only IP addresses starting with
\code{123.121.123}:</p>

<pre><code class="splus">expt &lt;- experiment(N=1, auth=c(&quot;123.121.123.*&quot;, &quot;127.0.0.1&quot;))
</code></pre>

<pre><code>## Warning: cannot open file &#39;betr-SEATS.txt&#39;: No such file or directory
## Warning: Problem reading seats file betr-SEATS.txt
</code></pre>

<p>If you need more complex authentication, then you can pass a function to 
<code>auth</code>: see <code>?experiment</code> for more information.</p>

<h3>Seats and client IDs</h3>

<p>In the lab, you need to know how much to pay your subjects. This is typically 
done by seat number. To identify subject seats, betr looks for a <em>seats file</em>, 
with the standard name <code>betr_SEATS.txt</code>, in its working directory.</p>

<p>The seats file is a tab separated data file which looks like this:</p>

<table><thead>
<tr>
<th>seat</th>
<th>IP</th>
<th>cookie</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>111.1.1.123</td>
<td>AFDJKLRE</td>
</tr>
<tr>
<td>2</td>
<td>111.1.1.124</td>
<td>REAJKJKL</td>
</tr>
</tbody></table>

<p>betr identifies seats either by IP address, or by a cookie set on a client 
machine. (The latter is useful if your lab machines do not have static IP
addresses.)</p>

<p>You can create the seats file by hand, but it easier to use the function 
<code>identify_seats()</code>. This starts a simple web application on your server and
tells you the web address it is serving on. You can then go to this address
on each of your lab client computers, and enter the computer&#39;s seat number. 
The seats file will be created automatically.</p>

<p>When you call <code>experiment()</code>, betr looks for the seats file and prints a warning
if it can&#39;t be found. You can pass a non-standard path to the <code>seats_file</code> 
argument, or <code>seats_file=NULL</code> to suppress this warning and not look for seats
(e.g. in an internet experiment). If the seats file is found, <code>info(expt)</code> will
print out clients&#39; seats along with their ID.</p>

<p>At payment time, you can match your data to seats by running <code>merge_subjects</code>:</p>

<pre><code class="splus">mydf &lt;&lt;- merge_subjects(expt, mydf)
</code></pre>

<p>This assumes that <code>mydf</code> has a column named <code>id</code>. It will add columns including
<code>seat</code> to the data. You can then print a list of payments by doing something
like:</p>

<pre><code class="splus">profits &lt;- mydf$[mydf$period=10, c(&quot;profit&quot;, &quot;seat&quot;)]
profits &lt;- profits[order(profits$seat),]
write.csv(profits, file=&quot;profits.csv&quot;)
</code></pre>

<h3>Easy commands</h3>

<p>You may not always want to run an experiment yourself. If your
experiment administrator does not know R, he or she may find the R command line quite
intimidating. To simplify, you can add the line <code>load_commands(expt)</code> to your
source file. Then, instead of typing e.g. <code>ready(expt)</code>, the administrator can
just type <code>READY</code>:</p>

<pre><code class="splus">myexpt &lt;- experiment(N=3, seats_file=NULL, record=FALSE)
info(expt)
</code></pre>

<pre><code>## Name: betr   Status: Stopped Clients: 0/1    Periods: 0  Stages: 0
</code></pre>

<pre><code class="splus">load_commands(myexpt)
READY
</code></pre>

<pre><code>## starting httpd help server ... done
</code></pre>

<pre><code>## 
## Server started on host 127.0.0.1 and port 35538 . App urls are:
## 
##  http://127.0.0.1:35538/custom/betr
</code></pre>

<pre><code class="splus">INFO
</code></pre>

<pre><code>## Session: betr-2014-05-22-145147  Status: Waiting Clients: 0/3    Periods: 0  Stages: 0
## Serving at http://127.0.0.1:35538/custom/betr
</code></pre>

<p>The commands that can be used are <code>READY</code>, <code>START</code>, <code>PAUSE</code>, <code>RESTART</code>, <code>HALT</code>, 
<code>INFO</code>, <code>MAP</code> and <code>WEB_TEST</code>. </p>

<h2>Running experiments online</h2>

<p>TODO&hellip;</p>

</body>

</html>

